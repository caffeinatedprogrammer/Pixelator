{"version":3,"sources":["InputForm.jsx","InputPage.jsx","Result.jsx","util.js","ResultPage.jsx","App.js","serviceWorker.js","index.js"],"names":["InputForm","onSubmit","useState","imageWidth","setImageWidth","imageHeight","setImageHeight","tileWidthCount","setTileWidthCount","k","setK","imageData","setImageData","canvasRef","useRef","handleFileInputChange","useCallback","event","reader","FileReader","onload","image","src","result","readAsDataURL","target","files","Image","width","height","current","context","getContext","drawImage","getImageData","data","handleTileWidthCountChange","value","handleKChange","handleSubmit","preventDefault","Number","className","type","onChange","onClick","ref","toString","InputPage","props","history","useHistory","push","pathname","state","Result","rows","i","j","index","pixel","slice","key","style","backgroundColor","display","margin","map","array","averageData","sumR","sumG","sumB","sumAlpha","length","forEach","getSimplifiedImage","a","async","tileSize","Math","floor","newData","Array","l","reduce","b","from","concat","getClusteredImage","K","matrix","Promise","resolve","kmeans","clusterize","err","res","getResult","entry","indices","clusterInd","centroid","splice","ResultPage","useLocation","useEffect","clustered","getImage","App","basename","process","exact","path","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.d3d14e3f.chunk.js","sourcesContent":["import React, { useCallback, useState, useRef } from \"react\";\nimport \"./InputPage.css\";\n\nexport default function InputForm({onSubmit}) {\n    const [imageWidth, setImageWidth] = useState(0);\n    const [imageHeight, setImageHeight] = useState(0);\n    const [tileWidthCount, setTileWidthCount] = useState(20);\n    const [k, setK] = useState(5);\n    const [imageData, setImageData] = useState();\n    const canvasRef = useRef();\n    const handleFileInputChange = useCallback((event) => {\n        const reader = new FileReader();\n        reader.onload = () => image.src = reader.result;\n        reader.readAsDataURL(event.target.files[0]);\n        const image = new Image();\n        image.onload = () => {\n            setImageWidth(image.width);\n            setImageHeight(image.height);\n            if (canvasRef.current) {\n                const context = canvasRef.current.getContext('2d');\n                context.drawImage(image, 0, 0, image.width, image.height);\n                setImageData(context.getImageData(0, 0, image.width, image.height).data);\n            }\n        };\n    }, [canvasRef, setImageData, setImageWidth, setImageHeight]);\n    const handleTileWidthCountChange = useCallback((event) => {\n        setTileWidthCount(event.target.value);\n    }, [setTileWidthCount]);\n    const handleKChange = useCallback((event) => {\n        setK(event.target.value);\n    }, [setK]);\n    const handleSubmit = useCallback((event) => {\n        event.preventDefault();\n        onSubmit && onSubmit(imageData, imageWidth, imageHeight, Number(tileWidthCount), k);\n    }, [onSubmit, tileWidthCount, imageData, imageWidth, imageHeight, k]);\n    \n    return (\n        <>\n            <div className=\"container\">\n                <input type=\"file\" onChange={handleFileInputChange} />\n                <input\n                    type=\"number\"\n                    onChange={handleTileWidthCountChange}\n                    value={tileWidthCount}\n                />\n                <input\n                    type=\"number\"\n                    onChange={handleKChange}\n                    value={k}\n                />\n                <button onClick={handleSubmit}>\n                    Submit\n                </button>\n            </div>\n            <div>\n                <canvas\n                    ref={canvasRef}\n                    width={imageWidth.toString()}\n                    height={imageHeight.toString()}\n                />\n            </div>\n        </>    \n    );\n}","import React from \"react\";\nimport InputForm from \"./InputForm\";\nimport { useHistory } from 'react-router-dom';\n\nexport default function InputPage(props) {\n    const history = useHistory();\n    const onSubmit = (data, imageWidth, imageHeight, width, k) => {\n        history.push({\n            pathname: \"/result\",\n            state: {data, imageWidth, imageHeight, width, k},\n        });\n    };\n    \n    return (\n        <InputForm onSubmit={onSubmit} />\n    );\n}","import React from 'react';\n\nexport default function Result(props) {\n    const { data, width, height} = props;\n    if (!data) return <div />;\n    const rows = [];\n    for (var i=0; i<height; i++) {\n        rows.push([]);\n        for (var j=0; j<width; j++) {\n            const index = 4*(i*width+j);\n            const pixel = data.slice(index, index+4);rows[i].push(\n                <div key={`${i} ${j}`} style={\n                    {\n                        backgroundColor: `rgb(${pixel[0]}, ${pixel[1]}, ${pixel[2]}, ${pixel[3]})`,\n                        width: \"30px\",\n                        height: \"30px\",\n                        display: \"inline-block\",\n                        margin: \"2px\"\n                    }\n                } />\n            )\n        }\n    }\n    \n    return (\n        <div>\n            {rows.map(((array, index) => \n                <div key={index.toString()}>{array}</div>      \n            ))}\n        </div>\n    )\n}","import kmeans from 'node-kmeans';\n\nexport function averageData(data) {\n    var sumR = 0;\n    var sumG = 0;\n    var sumB = 0;\n    var sumAlpha = 0;\n    const length = data.length / 4;\n    data.forEach((value, index) => {\n        switch (index % 4) {\n            case 0:\n                sumR += value;\n                break;\n                \n            case 1:\n                sumG += value;\n                break;\n                \n            case 2:\n                sumB += value;\n                break;\n                \n            case 3:\n                sumAlpha += value;\n                break;\n                \n            default:\n                break;\n        }\n    });\n    return [sumR, sumG, sumB, sumAlpha].map((value) => value/length);\n}\n\nexport async function getSimplifiedImage(data, imageWidth, imageHeight, width) {\n    const tileSize = Math.floor(imageWidth/width);\n    const height = Math.floor(imageHeight/tileSize);\n    const newData = new Array(width*height);\n    // truncate image at bottom\n    for (var i=0; i<height; i++) {\n        for (var j=0; j<width; j++) {\n            // find out which tile the pixel belongs to\n            for (var k=i*tileSize; k<(i+1)*tileSize; k+=10) {\n                for (var l=j*tileSize; l<(j+1)*tileSize; l+=10) {\n                    if (!newData[i*width+j]) {\n                        newData[i*width+j] = [];\n                    }\n                    const pixel = k*imageHeight + l;\n                    newData[i*width+j].push(data.slice(4*pixel, 4*pixel+4));\n                }\n            }\n        }\n    }\n    return newData.map((array) => averageData(array.reduce((a, b) => Array.from(a).concat(Array.from(b)))))\n                  .reduce((a, b) => a.concat(b));\n}\n\nexport async function getClusteredImage(data, K) {\n    const matrix = [];\n    for (var i=0; i<data.length; i+=4) {\n        matrix.push(data.slice(i, i+4));\n    }\n    return new Promise((resolve) => kmeans.clusterize(matrix, {k: K}, (err, res) => {\n        resolve(res);\n    }));\n}\n\nexport async function getResult(data, K) {\n    const result = await getClusteredImage(data, K);\n    for (const entry of result) {\n        const indices = entry.clusterInd;\n        const centroid = entry.centroid;\n        for (const index of indices) {\n            data.splice(index*4, 4, ...centroid);\n        }\n    }\n    return data;\n}\n\n\n\n\n\n\n\n\n\n\n\n","import React, { useEffect, useState } from 'react';\nimport { useLocation } from 'react-router-dom';\n\nimport Result from './Result';\nimport { getSimplifiedImage, getResult } from './util';\n\nexport default function ResultPage(props) {\n    const location = useLocation();\n    const state = location.state;\n    const { data, imageWidth, imageHeight, width, k } = state;\n    const [imageData, setImageData] = useState();\n    \n    useEffect(() => {\n        const getImage = async () => {\n            const image = await getSimplifiedImage(data, imageWidth, imageHeight, width);\n            const clustered = await getResult(image, k);\n            setImageData(clustered);\n        };\n        getImage();\n    }, [data, imageWidth, imageHeight, width, k]);\n    \n    return (\n        <Result data={imageData} width={width} height={Math.floor(imageHeight/Math.floor(imageWidth/width))} />\n    );\n}","import React from 'react';\nimport InputPage from './InputPage';\nimport ResultPage from './ResultPage';\nimport './App.css';\n\nimport { BrowserRouter, Switch, Route } from 'react-router-dom';\n\nfunction App() {\n    return (\n        <div className=\"App\">\n        <BrowserRouter basename={process.env.PUBLIC_URL}>\n            <Switch>\n                <Route exact={true} path=\"/result\">\n                    <ResultPage />\n                </Route>\n                <Route exact={true} path=\"/\">\n                    <InputPage />\n                </Route>\n            </Switch>\n        </BrowserRouter>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}